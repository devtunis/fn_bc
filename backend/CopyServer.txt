import 'dotenv/config';          // ← this loads .env automatically
 
import express from 'express';
import { Server } from 'socket.io';
import {createServer} from "node:http"
import createid from './createidRoom.js';
import Quee from './Quee.js';
import {emitUser,emitone} from './functionEit/emitUser.js';
import cleanupOffeers from './functionEit/cleanupOffeers.js';
 
import { CleanUpDIvorce, MatchingCouple, MatchingCoupleSpecial } from './functionEit/cleanUpDIvorce.js';
import { Mutex } from 'async-mutex';
import { Make, Make2 } from './handlers/Handlers.js';
 
 
const app = express();

const httpServer = createServer(app)
const io  = new Server(httpServer,{
    cors:{
        origin:"http://localhost:5173"
    }
})
 
// io.use((socket, next) => {
 //  const key = socket.handshake.auth.key;
 

  // if (key !== "super-secret-123") {
    // return next(new Error("Unauthorized"));
   //}

  // socket.isAuthorized = true;
  // next();
 //});>
 
function r(x){
  console.log(x)
}

function fetchRooms(){
          const arr  = []
          const  pairs  = [...queeSet.getrooms().values()].map((r)=>r.peers)
          pairs.forEach((item)=>{
          const r = {id:item[0]+item[1],x : item[0],y:item[1]}
          arr.push(r)
          })
         
          io.emit("disconnectPeople",arr)
}





 

const queeSet = new Quee()

const userLocks = new Map();


function getUserLock(userId) {
  if (!userLocks.has(userId)) userLocks.set(userId, new Mutex());
  return userLocks.get(userId);
}

async function runWithUserLocks(users, fn) {
 
  const sortedUsers = [...users].sort();
  const acquiredLocks = [];

  try {
    for (const u of sortedUsers) {
      const lock = getUserLock(u);
      await lock.acquire();
      acquiredLocks.push(lock);
    }

    await fn() 
  } finally {
   
    acquiredLocks.forEach(lock => lock.release());
  }
}

 
// Featuers tomorow -------
// socket.on("SwapNodes", ({ target }) => {

  //  const sender = socket.id;   // ده الحقيقي
   // const me = target;

   // validation هنا
   //});

// const ActionType = {
//   RESET_MATCH: "resetMatch",
//   ALONE_PERSON: "aloneperson",
//   SESSION_MATCHING: "sessionMatching"
// }



//   function HandelResponse(pairs,actionType,io,queeSet){
   
//     pairs.length > 0 && (() => {
//         pairs.forEach((id)=>{
           
//           switch(actionType){
//             case ActionType.RESET_MATCH:
//              CleanUpDIvorce(io,queeSet,id[0],id[1])
//             break
//             case ActionType.ALONE_PERSON:
//               emitone(io,"alone",id,true)
//             break
//             case ActionType.SESSION_MATCHING:
//             MatchingCouple(io,queeSet,id[0],id[1])
//             break
//           }
//         })
//     })();


//   }


  


io.on("connection",(socket)=>{

  console.log("connected ✅",socket.id)
 
  












//-----------------------------------------Accept offer and swap nodes betwen sender offer and president----------------------------------------------
 //  HandelResponse(SkipResponse[TypeAction],TypeAction,io,queeSet)

//  {
//   idCleanDivorces: [
//     [ 'eRE3miL6FAI0pZbPAAAH', 'uqguH9OrJoCNH55QAAAJ' ],
//     [ 'DVf_oCGQZMINDPMyAAAD', '4oLjkmbpC8ebXOSxAAAF' ]
//   ],
//   MatchingCouple: [ [ 'eRE3miL6FAI0pZbPAAAH', 'DVf_oCGQZMINDPMyAAAD' ] ],
//   MatchingSpecialCouple: [ [ 'uqguH9OrJoCNH55QAAAJ', '4oLjkmbpC8ebXOSxAAAF' ] ],
//   AlonePerson: [ 'uqguH9OrJoCNH55QAAAJ' ] fix this bug if you find one in the list
  

 socket.on("SwapNodes",async({sender,me})=>{

    await  runWithUserLocks([sender, me], async () => {

    const array = queeSet.AccetSawap(sender,me)


 
    array["idCleanDivorces"] && array["idCleanDivorces"].forEach((item)=>{
      CleanUpDIvorce(io,queeSet,item[0],item[1])
      
    })
    array["MatchingCouple"] &&   array["MatchingCouple"].forEach((item)=>{
      MatchingCouple(io,queeSet,item[0],item[1])
    })
    array["AlonePerson"] &&  array["AlonePerson"].forEach((item)=>{
       emitone(io,"alone",item,true)
    })
   array["MatchingSpecialCouple"] &&  array["MatchingSpecialCouple"].forEach((item)=>{
      MatchingCoupleSpecial(io,queeSet,item[0],item[1])
    })
    console.log(array,"<== this rooms any")
    fetchRooms()
 
    })
  

   
 })




//-----------------------------------------swap node----------------------------------------------




// featurs skip for tomowor to ledn this 
// check point for tromower
// and devtools   line 87 check it  for hack {target}
// and ask the users if good idea when do bussines layer and not for scoket io happend things
// and do skipp button fro all layres
// and do race condtion of users skippper : : : :: :: : important
// and see beahvior many skeep this button apepar <skip>
// do  function to all this stuff


socket.on("Unlock",  ({id})=>{

      const SkipResponse = queeSet.HandelSkip(id)
 
      for(const TypeAction in SkipResponse){
       Make[TypeAction](io,queeSet,SkipResponse[TypeAction])
      }
      console.log(SkipResponse)
      fetchRooms()

 })
 
 




socket.on("swap",(id)=>{
  console.log(queeSet.getrealtionoffer())
})











if(socket.id!=undefined){
  queeSet.AddItem(socket.id)
}

const  next = queeSet.bringIce(socket.id)
if(!next) {
  
    emitone(io,"alone",socket.id,true)
   
}
else{
 
   
 
   
     cleanupOffeers(queeSet,next,io)

     queeSet.delete(socket.id)
     queeSet.delete(next)
 
     emitUser(io,"matching",next,socket.id,true)
     queeSet.AddCouple(next,socket.id)
}



socket.on("SwitchPrivateOffer",({target,sender})=>{
    console.log(target,sender,"key",[target,sender].sort().join("_"))
    queeSet.addRealtionCheat(sender,target)
    io.to(target).emit("SwitchPrivateOffer",{sender,msg:"ask for matche"})
    
})
socket.on("ice-candidate",({candidate,target })=>{
  io.to(target).emit("ice-candidate",candidate)
 
})
 socket.on("Offer",({sdp,target,myid })=>{
   
  io.to(target).emit("Offer",{sdp,myid})
 
})
socket.on("Answer",({sdp,target})=>{
 
  io.to(target).emit("Answer",sdp)
})
socket.on("showQuee",()=>{
     const date = new Date()
     queeSet.display()
     console.log(`${date.getHours()}:${date.getMinutes()}:${date.getMilliseconds()}`)
  

    

})
socket.on("listenRooms",(room)=>{
      
     queeSet.addChannel(room.Key,{peers :room.peers})
     io.emit("roomsTalking",{uniqueId : room.Key,x : room.peers[0],y :room.peers[1]}); 
    

})
socket.on("PrivateMessage",({type,target,Sender,msg,time})=>{
    
  io.to(target).emit("PrivateMessage",{type,Sender,msg,time})
})
socket.on("getusers",()=>{
    const arr = []
      const pairs = [...queeSet.getrooms().values()].map((i)=>i.peers)
      pairs.forEach((item)=>{
      const r = {id:item[0]+item[1],x : item[0],y:item[1]}
      arr.push(r)
      })
       


  socket.emit("receiveUsers",arr)
})

socket.on("disconnect",()=>{
 
   const ResponseDisconnect   = queeSet.HandelDisconnect(socket.id)
   for(const TypeOfAction in ResponseDisconnect){
  
    Make2[TypeOfAction](io,queeSet,ResponseDisconnect[TypeOfAction])
    
   }

   console.log(ResponseDisconnect)
   fetchRooms()
  })
 
 
})
 






const PORT = process.env.PORT || 5000;
httpServer.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
 















